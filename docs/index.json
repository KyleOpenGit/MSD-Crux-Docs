{
  "docs/guide/crux/crux-server.html": {
    "href": "docs/guide/crux/crux-server.html",
    "title": "Crux Server | MESCADAS Crux",
    "keywords": "Crux Server ■ Application Architecture CruxServer는 아래와 같은 계층형 구조로 이루어져있습니다: Host Presentation Infrastructure DI (.Shared) Core ■ HOST 프로젝트 Host는 MSD Crux 서버의 실행 진입점으로, 클라이언트 요청에 대해 Presentation 계층의 각 엔드포인트에대한 라우트 매핑을 담당합니다. Host 프로젝트는 CruxServer 솔푸션폴더 내의 유일한 실행 타입 프로젝트이며, MSD.Crux.Host의 Program클래스는 MSD Crux 서버의 진입점입니다. 클라이언트가 요청하는 각 Presentation으로 라우트합니다. 환경변수와 구성파일 MSD Crux는 ASP.NET 구성파일 (appsettngs.json)을 통해서도 JWT 시크릿 키, DB 커넥션 스트링등의 정보룰 로드할 수 있습니다 (OS의 환경변수 직접제공하거나 실행파일 명령줄 옵션을 통한 설정보다 우선순위 낮음) . MSD Crux는 ASPNETCORE_ENVIRONMENT 환경에 맞는 환경 구성파일을 로드하며 .NET 환경변수 ASPNETCORE_ENVIRONMENT의 값은 다음 중 하나임을 상정합니다: Local : 개발용 로컬 컴퓨터 환경 구성 Development : dev 서버용 환경 구성 Production : prod 서버용 환경 구성 IDE상의 실행 환경은 launchSettings.json의 프로파일 중 environmentVariables:ASPNETCORE_ENVIRONMENT 의 값을 변경하여 실행하면 됩니다. \"profiles\": { \"http\": { \"commandName\": \"Project\", \"dotnetRunMessages\": true, \"launchBrowser\": true, \"launchUrl\": \"swagger\", \"applicationUrl\": \"http://localhost:5282\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Local\" } } } 환경별 구성 파일 appsettings.{환경}.json 파일 중 다음 두 파일에대해서는 Git이 트래킹하지 않습니다(gitignore에 등록되어있음). appsettings.Development.json appsettings.Production.json 두 파일은 각각 dev 서버와 prod 서버 배포시 포함할 수 있는 파일로, JWT 시크릿키, DB 커넥션스트링을 적어둘 수 있습니다. 로컬 컴퓨터 개발 환경에서만 사용되어야할 appsettings.Local.json 파일이 샘플로서 포함되어있습니다. 이 파일을 참고하여 각 서버에 배포시에는 그에 맞는 구성파일을 직접 생성, 포함해 배포 해야 합니다. Important appsettings.json 혹은 appsettings.Local.json 파일에는 실제 서버 또는 DB의 비밀정보를 작성하지 마십시오. 이 파일들은 Git 트래킹되므로 외부에 공개됩니다. 환경 구성 파일의 비밀정보 보호에 대해서는 추가로 환경별 서버 구성과 Git 브랜치 전략의 내용을 읽어보시기 바랍니다. Note 환경변수와 구성파일에 대한 기본내용은 MS Docs의 다음 문서를 참고 하십시오. ASP.NET Core의 옵션 패턴 ASP.NET Core에서 여러 환경 사용"
  },
  "docs/guide/crux/dev-tool.html": {
    "href": "docs/guide/crux/dev-tool.html",
    "title": "The DevTool | MESCADAS Crux",
    "keywords": "The DevTool MSD.Crux.DevTool은 셸 명령어 프로그램 개발을 위한 프로젝트입니다. CLI 명령어용 프로그램은 셸명령어를 통해서 명령어 옵션(App arguments)과 함께 실행된 뒤 작업을 마치고 곧바로 종료되는 방식으로 작동하므로 IDE에서 단지 실행해보는 것은 의미가 없습니다. IDE에서 RUN과 함께 명령어를 실행하고 싶다면 각 IDE의 RUN Configuration 설정에서 원하는 명령어를 설정해두고 RUN 하시기 바랍니다. Visual Studio: Application arguments JetBranins Rider: Run/Debug Configuration Visual Studio Code: launch.json에서 Arguments 설정 또는 직접 배포, Shell에 등록 후 배포환경에서 명령어를 실행 하세요. 지원 명령어 및 옵션 루트 명령어: crux-dev-tool System.CommandLine 기본 명령어 옵션: --help --version 루트 명령어 추가 옵션 --app-version"
  },
  "docs/guide/p-guide.html": {
    "href": "docs/guide/p-guide.html",
    "title": "프로그래밍 가이드 | MESCADAS Crux",
    "keywords": "프로그래밍 가이드 PREREQUISITES 개발 환경: .NET 8 SDK를 실행할 수 있는 OS .NET 개발을 지원하는 IDE 또는 코드 에디터 .NET 8 SDK 이상이 설치된 환경 ASP .NET and web development 워크로드 개발자: C#과 .NET Core 개발에대한 기본적인 이해 CLI (명령줄 인터페이스)에대한 익숙함 Git 과 Github에대한 익숙함 실행파일 배포 환경 (서버 컴퓨터) 필수: .NET 8 및 ASP.NET 8 이상 Runtime 이 실행될 수 있는 Linux or Windows or macOS Git 레포지토리 깃헙 레포지토리 페이지의 Code 에서 URL을 복사해서 로컬 컴퓨터에서 Clone 하면 Git 커밋이력과 함께 복제됩니다. Git 이력이 필요없다면 다운로드만 하세요. git clone https://github.com/KyleOpenGit/Msd-Crux-repo.git Note 새롭게 Clone 했을 때에는 자동 코드 포매팅을 위해 Git pre-commit 훅 설정을 참고 해주세요. Crux 서버 소스코드가 있는 Github 레포지토리에는 닷넷 솔루션 뿐만 아니라 기타 다른 구성도 함께 합니다. 개발환경 기타 옵션에대해서는 Git레포지토리의 README.md 내용을 참고하세요."
  },
  "docs/guide/solution-structure.html": {
    "href": "docs/guide/solution-structure.html",
    "title": "솔루션 구조 | MESCADAS Crux",
    "keywords": "솔루션 구조 MSD.Crux 닷넷 솔루션은 여러 닷넷 프로젝트로 이루어져 있으며, Git repository의 root 하위에 src/MSD.Crux폴더가 닷넷 솔루션의 작업 디렉토리(Working Directory)입니다. Git 루트 디렉토리를 열어도 대부분의 IDE에서 닷넷 솔루션과 프로젝트를 잘 표시하게 될 것입니다. msd-crux-repo/ ├── src/ │ ├── DocFX │ └── MSD.Crux/ # working directory │ └── MSD.Crux.sln │ └── # 다른 닷넷 프로젝트 폴더들 │ └── .editorconfig │ └── global.json ├── # 기타 └── README.md 컴퓨터 폴더구조로는 나타나지 않지만, 닷넷의 솔루션 폴더 구조를 지원하는 IDE에서 열게되면 아래처럼 각 프로젝트가 나누어져있습니다. CruxServer : MSD Crux 서버 애플리케이션 MSD.Crux.Host : 실행파일 프로젝트 Standalone : 각각의 프로젝트가 독립적으로 실행가능한 애플리케이션 TCPServer: 별도로 분리된 MSD Crux 서버의 TCP 소켓 통신 서버 애플리케이션 DevTool: CLI 명령어 프로그램 개발을 위한 콘솔 앱 프로젝트 TCPClient: MESCADAS 엣지클라이언트의 TCP 클라이언트 테스트코드 Testing : 단위 테스트등의 코드를 위한 프로젝트 Important 각 프로젝트는 서로다른 참조 관계가 맺어져 있으므로 순환참조가 일어나지 않도록 주의 해야합니다. 멀티 프로젝트 실행 Executable type 프로젝트는 배포시 각각의 실행파일로 배포될 수 있습니다. IDE의 RUN/DEBUG 환경으로 동시 실행 가능합니다. 멀티 프로젝트를 실행하려면 각 IDE의 기능을 활용하세요: Visual Studio: Multiple Startup Projects Visual Studio Code : Compound Launch Configuration JetBrains Rider : Compound Run/Debug Configuration"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "MESCADAS Crux | MESCADAS Crux",
    "keywords": "MESCADAS Crux MESCADAS Crux는 MESCADAS 프로젝트 의 중앙 서버 웹애플리케이션으로, MESCADAS 핵심 서비스의 관리와 조율을 위한 중심 허브 역할을 수행하도록 설계됩니다. 강력하고 고성능의 .NET Core를 기반으로 구축된 MESCADAS Crux는 현대 애플리케이션을 위한 확장 가능하고 신뢰할 수 있는 기반을 제공합니다. 이하, MSD Crux MSD Crux 서버 기능 크로스 플랫폼 지원 (C# ASP.NET Core 8) 높은 확장성 Restful API TCP Socket Server 비밀번호 암호화 JWT (제이슨 웹 토큰) 발급 및 검증 독립적인 테스팅 애플리케이션 아키텍처 LAYERED ARCHITECTURE MSD Crux 서버의 코드는 계층형으로 나누어져 설계되었습니다. 이러한 계층형 모듈화는 기능 추가가 쉽습니다. 인프라스트럭처 계층에서는 In-Memory 저장소와 PostgreSQL DB 저장소만 다루는 SQL가 작성되어 있지만, 여기에 MySQL을 위한 코드를 추가 작성하여 언제든 상황에따라 원하는 코드로 동작되도록 선택할 수 있습니다. 프리젠테이션 계층에는 지금은 웹API 기능과 소켓통신 기능이 같은 서버에 있지만 각각 다른 애플리케이션으로 분리해낼 수 있습니다. 그리하여 여러기능을 독립적으로 분리한 마이크로 서비스로 확장하기 쉽게 설계 되었습니다. 이렇게 여러 기능으로 분리해 낼 때 변경이 필요없는 계층은 코드를 재작성하거나 복사할 필요 없이 라이브러리 파일로 임포팅해서 개발이 가능합니다. 이러한 분리구조는 또한 Unit Test를 가능케하여 각 계층별 코드를 독립적으로 테스팅할 수 있습니다. HEADLESS ARCHITECTURE MSD Crux 서버는 데이터 저장/조회를 위한 플러그인방식의 인터페이스 설계, 그리고 표준화된 통신 API 구현으로인해 Database나 클라이언트의 기능과는 완전하게 분리된 구조의 헤드리스 아키텍처로 구성됩니다. 전체 시스템이 3-Tier 구조를 이룰 수 있어 클라우드 친화적으로 고가용성, 고성능의 서비스 제공을 꾀 할 수 있습니다 클라우드 배포시 데이터베이스는 클러스터링을 구성하고, Crux 서버 애플리케이션을 수평적 스케일링에 유리합니다. 또한 표준화된 API와 프로토콜 설계로 PC, MAC, 웹, 모바일, iOT 등 다양한 클라이언트가 만들어져도 손쉽게 대응 가능합니다. DB 보안 및 서버 보안 네트워크 보안 위와 같은 헤드리스 아키텍처를 기반으로 사설 VPC/SUBNET 구성을 통해서 Database를 보호 할 수 있습니다. private subnet 구성을 통해 DB를 인터넷에 노출하지 않게하고 클라이언트에는 DB 접속을 위한 비밀정보를 저장하지 않은 채 오직 Crux 서버를 통해서만 데이터를 조회하도록 구성할 수 있습니다. 암호 보호 & JWT MESCADAS는 적법한 권한을 가진 작업자만이 클라이언트를 이용하고 서버에 데이터 전송/조회할 수 있도록 로그인 수단이 제공됩니다. 시스템 사용권한이 인가된 User의 비밀번호는 해독불가능한 암호문으로 DB에 저장됩니다. 엣지 클라이언트에서 User가 로그인 시 Crux 서버는 보안키를 이용해 JWT(Json Web Token)과 공개키를 발급하며, 되돌려받아 검증된 토큰과 함께 데이터 요청을 했을 때만 클라이언트와 데이터를 교환합니다. 클라이언트는 또한 서버로부터 받은 공개키를 통해 로컬 토큰을 검증하고 로그인 User의 Role 권한에 따라 특정 기능을 제한하거나 제공하도록 개발할 수 있습니다."
  },
  "docs/rest-api.html": {
    "href": "docs/rest-api.html",
    "title": "Web API | MESCADAS Crux",
    "keywords": "Web API"
  },
  "index.html": {
    "href": "index.html",
    "title": "MESCADAS - 지능형 스마트팩토리 시스템 | MESCADAS Crux",
    "keywords": "MESCADAS - 지능형 스마트팩토리 시스템 ■ MESCADAS 소개 MESCADAS(메스카다스, 이하 MSD)는 생산관리와 실시간 모니터링, AI를 이용한 불량판별 그리고 그것들을 위한 데이터 수집시스템을 C# .NET 스택으로 구현한 클라우드 친화적인 지능형 스마트 팩토리 시스템 입니다. MSD는 여러 서버 애플리케이션과 클라이언트 소프트웨어가 하나의 큰 시스템을 이루고 있습니다. 본 사이트는 그 중 서버 애플리케이션인 MSD Crux의 문서 사이트입니다. MSD Crux 서버 소스코드 (Github) 문서 페이지 (현재 사이트) Note MESCADAS의 소스코드는 지능형 스마트팩토리 시스템의 개념을 시연할 수 있는 프로토타입으로, 실제 산업 현장에 적용된 사례는 아닙니다. ■ MESCADAS 전체 시스템 구성 System Architecture 서버그룹과 엣지 클라이언트 MSD Crux 서버 소스코드 by 김카일 문서 페이지 MESCADAS의 중심에서 클라이언트와 데이터베이스 통신을 수행하는 Crux 서버 애플리케이션은 .Net Core로 개발된 크로스플랫폼 서버 애플리케이션으로, Windows 뿐만 아니라 Linux 에서도 실행될 수 있습니다. Database 데이터베이스는 관계형 데이터와 시계열 데이터를 함께 다루기 위해 PostgreSQL & TimescaleDB 구성으로 이루어져있습니다. Message Broker 메시지 브로커는 오픈소스 애플리케이션인 RabbitMQ가 실행되어 엣지 클라이언트들의 메시지 발행과 구독을 중계합니다. 데이터 어노테이션 서버 데이터 어노테이션 서버는 MESCADAS 시스템이 작동하기위한 필수 서버는 아니지만 AI 학습에 사용되었습니다. 오픈소스 웹 애플리케이션이 Label Studio는 MESCADAS의 품질검사 공정에 쓰이는 AI 학습을 위한 사진에 Labeling 하기위한 작업을 여러사람이 웹사이트에 로그인하여 협업할 수 있도록 해줍니다. 이로인해 방대한 량의 작업을 분담할 수 있습니다. 또한 여러 AI 학습 모델의 트레이닝 데이터로 내보낼 수 있어, 추가적인 자동화를 구축하면 완료된 작업을 내보내 로컬 또는 클라우드 트레이닝 서버를 생성하여 학습을 실행할 수 있겠습니다. 엣지 클라이언트는 MESCADAS 시스템의 최전선에서 공장 사무실PC와 작업현장에서 관리자와 작업자와 밀접하게 상호작용 할 수 있는 UI를 갖추고, PLC 생산설비와 AI 품질 공정에서 데이터를 수집하여 서버로 전송합니다. MSD MES 소스 코드 by 한민기 MSD MES는 .NET WPF 프레임워크로 개발된 사무실 관리자용 프로그램으로, 생산계획 수립, 생산/품질검사 현황 모니터링을 수행할 수 있도록 개발되었습니다. MSD PLC HMI 소스 코드 by 신종덕 MSD PLC HMI는 공장 생산라인 작업자가 콘트롤하는 전용 HMI 디바이스 컨셉의 윈도우 프로그램으로써, .NET Winforms로 개발되었습니다. PLC와 인버터, 온도콘트롤러를 통해 생산설비를 제어하며 데이터를 수집하고 서버로 전송합니다. MSD Vision HMI 소스 코드 by 조현빈 MESCADAS의 AI 품질검사 설비를 제어하는 MSD Vision HMI는 .NET Winforms로 개발되었습니다. Arduino를 시리얼통신 명령어 프로토콜로 제어하며 공장의 불량판별 기준으로 학습된 AI 모델을 내장하여 웹캠을 통해 비전검사를 수행하며, 데이터를 수집하여 서버로 전송합니다. ■ 통신 프로토콜 Servers ⇔ Edge Clients 통신 프로토콜 서버와 클라이언트간 통신은 다음과 같습니다. RESTful API (표준 Web API) TCP Socket (OSI 4계층 커스텀 프로토콜) MQTT (메시지 브로커를 통한 Pub & Sub) Edge Clients ⇔ Devices 통신 프로토콜 산업현장의 다양한 필드버스 프로토콜 중 일부와 커스텀 프로토콜이 구현되어 있습니다. MQTT 프로토콜 (인터넷, 메시지 브로커와의 Pub & Sub) MODBUS RTU 프로토콜 (RS485, 템코라인 온도콘트롤러, LS산전 인버터) SLMP 프로토콜 (이더넷, 미쯔비시 MELSEC PLC) 명령어 프로토콜 (시리얼통신, 아두이노 제어) ■ 시작하기 서버 구성에대해서는 MSD Crux 서버 문서 에서 더 자세한 내용을 보실 수 있습니다."
  }
}